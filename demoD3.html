<!DOCTYPE html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="style.css" />
<style>
body {
  text-align: center;
  color: black;
}

#ktable {
  position: absolute;
  top: 1px;
  right: 0;
}

#ktable table {
  border-collapse: collapse;
  border-spacing: 0;
}

#ktable td {
  padding: 0;
}

#kripke {
  position: relative;
  margin: 0 auto;
}

#kripke svg {
  border: 1px solid black;
}
</style>
</head>
<body>
<div id="kripke">
<div id="ktable"></div>
</div>
<button onclick="colorMe();">Reset focus</button>
<div id="colorButtons"></div>
<p>
<form>
  <input type="text" name="missionTeam" placeholder="Mission team?" /> <br />
  <input type="number" name="numFails" placeholder="Number of fails?" /> <br />
  <label><input type="checkbox" name="forceFail" />Force spies to fail?</label> <br />
  <label><input type="checkbox" name="seeFails" />See number of fails?</label> <br />
  <!-- this is horrendous... -->
  <input type="button" onclick="missionResults(missionTeam.value, numFails.value, forceFail.checked, seeFails.checked)" value="Go on a mission!" />
</form>
</p>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="demoD3.js"></script>
<script>

var width = 400,
    height = 400;

var color = d3.scale.category10();

var force = d3.layout.force()
    .charge(-5000)
    .linkDistance(150)
    .friction(.95)
    .gravity(.18)
    .size([width, height]);

var svg = d3.select("#kripke")
    .style("width", width+"px")
  .append("svg")
    .attr("width", width)
    .attr("height", height);

var colorButtons = d3.select("#colorButtons");

var ktable = d3.select("#ktable")
  .append("table")
    .attr("onmouseout", "colorMe()");

function setData(graph) {
  var butt = colorButtons.selectAll("button")
      .data(graph.playerList);
  butt.exit().remove();
  butt.enter().append("button")
      .text(function(d){ return "Focus "+d; })
      .attr("onclick", function(d){ return "colorMe("+d+");"; });

  ktable.selectAll("tr")
      .data(graph.playerList)
    .enter().insert("tr")
      .attr("onmouseover", function(d){ return "colorMe("+d+");"; })
    .selectAll("td")
      .data(graph.playerList)
    .enter().insert("td")
      .style("height", "7px")
      .style("width", "7px");

  ktable.selectAll("tr").selectAll("td")
      .style("background", function(a,b,c) {
          var p1 = c+1, p2 = b+1;
          var possible = spyKnowledge(p1,p2,graph);
          return possible > 0 ? "red" : possible < 0 ? "green" : "yellow";
      });

  force
      .nodes(graph.worlds)
      .links(graph.links)
      .start();

  svg.selectAll(".link").remove();
  var link = svg.selectAll(".link")
      .data(force.links())
    .enter().append("line")
      .attr("class", "link")
      .style("stroke", function(d){ return color(d.player); })
      .style("stroke-width", 2);

  svg.selectAll(".gnode").remove();
  var gnodes = svg.selectAll(".gnode")
      .data(force.nodes(), function(d) { return d.spies;});
  gnodes = gnodes
    .enter().append("g")
      .classed("gnode", true)
      // Don't set node to fixed on mouseover.
      // This is a hack taken from http://jsfiddle.net/InferOn/5wssqqdw/1/
      // Not sure what the "proper" way to disable force.drag()'s mouseover is.
      .call(force.drag().on("drag",function(d){}));

  var node = gnodes.insert("circle")
      .attr("class", "node")
      .attr("r", 15)
      .style("fill", function(d) { return d.reality ? "red" : "lightblue"; });

  var labels = gnodes.insert("text")
      .attr("text-anchor", "middle")
      .attr("x", 0)
      .attr("y", ".3em")
      .text(function(d) { return d.spies; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    gnodes.attr("transform", function(d) {
       return "translate(" + [d.x, d.y] + ")";
    });
  });
}

// Returns -1 if p1 knows p2 is not a spy.
// Returns 0 if p1 holds it possible that p2 is a spy, but is not sure.
// Returns 1 if p1 knows p2 is a spy.
function spyKnowledge(p1, p2, graph) {
  var worlds = graph.worlds;
  var count = 0, myWorldCount = 0;
  for (var i = 0; i < worlds.length; i++) {
    if (worlds[i].spies.indexOf(p1) == -1) {
      myWorldCount++;
      if(worlds[i].spies.indexOf(p2) != -1) {
        count++;
      }
    }
  }
  return myWorldCount == 0 ? 1 : count == 0 ? -1 : count < myWorldCount ? 0 : 1;
}

function colorMe(p) {
  if (p === undefined) {
    svg.selectAll(".link")
        .style("stroke", function(d){ return color(d.player); })
        .style("stroke-width", 2);
  } else {
    svg.selectAll(".link")
        .style("stroke", function(d){ return d.player == p ? color(d.player) : "#eee"; })
        .style("stroke-width", function(d){ return d.player == p ? 3 : 1; });
  }
}

function findWorld(w, graph) {
  var worldNdx = undefined;
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (world === w || world.spies === w) {
      worldNdx = i;
      break;
    }
  }
  return worldNdx;
}

function removeWorld(w, graph) {
  var worldNdx = findWorld(w, graph);
  if (worldNdx === undefined) {
    console.log("Could not find world "+w);
    return false;
  }
  var world = graph.worlds[worldNdx];
  graph.worlds.splice(worldNdx, 1);
  for (var i = 0; i < graph.links.length; i++) {
    var link = graph.links[i];
    if (link.source === world || link.target === world) {
      graph.links.splice(i, 1);
      i--;
    }
  }
  return true;
}

function knownGood(player, graph) {
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (world.spies.indexOf(player) >= 0 || world.spiesRaw.indexOf(player) >= 0) {
      if (!removeWorld(world.spies, graph)) {
        console.log(world);
        console.log("WTF? "+i);
        return;
      }
      i--;
    }
  }
}

function knownBad(player, graph) {
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (world.resistance.indexOf(player) >= 0 || world.resistanceRaw.indexOf(player) >= 0) {
      if (!removeWorld(world.spies, graph)) {
        console.log(world);
        console.log("WTF? "+i);
        return;
      }
      i--;
    }
  }
}

// Find the length of the longest common subsequence of a and b. Assumes a and b are in sorted order.
function lenLCS(a, b) {
   var out = 0;
   for (var i = 0, j = 0; i < a.length && j < b.length; ) {
      if (a[i] == b[j]) {
         out++;
         i++;
         j++;
      } else if (a[i] < b[j]) {
         i++;
      } else {
         j++;
      }
   }
   return out;
}

function filterLenLCS(missionTeam, graph, f) {
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (!f(lenLCS(world.spies,missionTeam))) {
      if (!removeWorld(world.spies, graph)) {
        console.log("WTF? "+i);
        console.log(world);
        return;
      } else {
        console.log("Removing "+world.spies);
      }
      i--;
    }
  }
}

function missionResults(missionTeam, numFails, forceFail, seeFails) {
  missionTeam = missionTeam.split("").sort().join("");
  if (numFails == 0) {
    if (forceFail) {
      filterLenLCS(missionTeam, graph, function(f) { return f == 0; });
    }
  } else {
    if (seeFails) {
      filterLenLCS(missionTeam, graph, function(f) { return f == numFails; });
    } else {
      filterLenLCS(missionTeam, graph, function(f) { return f != 0; });
    }
  }

  setData(graph);
}

var graph = {};
function initKripke(spies, resistance) {
  graph.playerList = new Array(spies+resistance);
  for (var i = 0; i < spies+resistance; i++) {
    graph.playerList[i] = i+1;
  }

  graph.worlds = initWorlds(spies,resistance);

  graph.players = {};
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    for (var j in world.resistance) {
      var player = world.resistance[j];
      (graph.players[player] = graph.players[player] || []).push(world);
    }
  }

  graph.links = [];
  for (var player in graph.players) {
    var ws = graph.players[player];
    for (var i = 0; i < ws.length; i++) {
      for (var j = i+1; j < ws.length; j++) {
        graph.links.push({source: ws[i], target: ws[j], player: player});
      }
    }
  }

  //nodes[0].reality = true;

  setData(graph);
}
initKripke(2,3);
</script>
</body>
</html>
