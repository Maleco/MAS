<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

svg {
   -webkit-touch-callout: none;
   -webkit-user-select: none;
   -khtml-user-select: none;
   -moz-user-select: none;
   -ms-user-select: none;
   user-select: none;
}

</style>
<body>
<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="demoD3.js"></script>
<script>

var width = 600,
    height = 600;

var color = d3.scale.category20();

var force = d3.layout.force()
    .charge(-5000)
    .linkDistance(150)
    .friction(.95)
    .gravity(.15)
    .size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

function setData(graph) {
  force
      .nodes(graph.worlds)
      .links(graph.links)
      .start();

  svg.selectAll(".link").remove();
  var link = svg.selectAll(".link")
      .data(force.links())
    .enter().append("line")
      .attr("class", "link")
      .style("stroke-width", function(d) { return d.value; });

  svg.selectAll(".gnode").remove();
  var gnodes = svg.selectAll(".gnode")
      .data(force.nodes(), function(d) { return d.spies;});
  gnodes = gnodes
    .enter().append("g")
      .classed("gnode", true)
      .call(force.drag);

  var node = gnodes.insert("circle")
      .attr("class", "node")
      .attr("r", 15)
      .style("fill", function(d) { return d.reality ? "red" : "lightblue"; });

  var labels = gnodes.insert("text")
      .attr("text-anchor", "middle")
      .attr("x", 0)
      .attr("y", ".3em")
      .text(function(d) { return d.spies; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    gnodes.attr("transform", function(d) {
       return 'translate(' + [d.x, d.y] + ')';
    });
  });
}

function findWorld(w, graph) {
  var worldNdx = undefined;
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (world === w || world.spies === w) {
      worldNdx = i;
      break;
    }
  }
  return worldNdx;
}

function removeWorld(w, graph) {
  var worldNdx = findWorld(w, graph);
  if (worldNdx === undefined) {
    console.log('Could not find world '+w);
    return false;
  }
  var world = graph.worlds[worldNdx];
  graph.worlds.splice(worldNdx, 1);
  for (var i = 0; i < graph.links.length; i++) {
    var link = graph.links[i];
    if (link.source === world || link.target === world) {
      graph.links.splice(i, 1);
      i--;
    }
  }
  return true;
}

function knownGood(player, graph) {
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (world.spies.indexOf(player) >= 0 || world.spiesRaw.indexOf(player) >= 0) {
      console.log(world);
      if (!removeWorld(world.spies, graph)) {
        console.log('WTF? '+i);
        return;
      }
      i--;
    }
  }
}

function knownBad(player, graph) {
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    if (world.resistance.indexOf(player) >= 0 || world.resistanceRaw.indexOf(player) >= 0) {
      console.log(world);
      if (!removeWorld(world.spies, graph)) {
        console.log('WTF? '+i);
        return;
      }
      i--;
    }
  }
}

function missionResults(missionTeam, numFails, forceFail, canSeeNumFails) {
  if (numFails == 0 && forceFail) {
    for (var i = 0; i < missionTeam.length; i++) {
      knownGood(missionTeam[i], graph);
    }
  }

  setData(graph);
}

var graph = {};
function initKripke(spies, resistance) {
  graph.worlds = initWorlds(spies,resistance);
  graph.players = {};
  for (var i = 0; i < graph.worlds.length; i++) {
    var world = graph.worlds[i];
    for (var j in world.resistance) {
      (graph.players[world.resistance[j]] = graph.players[world.resistance[j]] || []).push(world);
    }
  }

  graph.links = [];
  for (var player in graph.players) {
    var ws = graph.players[player];
    for (var i = 0; i < ws.length; i++) {
      for (var j = 0; j < ws.length; j++) {
        graph.links.push({source: ws[i], target: ws[j], player: i});
      }
    }
  }

  //nodes[0].reality = true;

  setData(graph);
}
initKripke(2,3);
</script>
</body>
</html>
